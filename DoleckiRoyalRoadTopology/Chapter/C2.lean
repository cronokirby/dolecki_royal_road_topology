import Mathlib.Data.Set.Defs
import Mathlib.Data.Set.Basic

structure FilterSeed (α) where
  /-- A filter is a collection of subsets of α. -/
  sets : Set (Set α)

  /-- The meet property gives us some downward reachingness. -/
  meet : (x ∈ sets) → (y ∈ sets) → x ∩ y ∈ sets

  /-- We work with non-degenerate seeds, so we require inhabitation.

  Without this assumption, the filter generated by the seed may be degenerate.
  -/
  nonempty : sets.Nonempty

structure Filter (α) where
  seed : FilterSeed α
  /-- The isotone property makes a filter upwardly closed. -/
  isotone : x ∈ seed.sets → x ⊆ y → y ∈ seed.sets
  /-- The top subset of α must be in the filter.

  This means that we only work with non-degenerate filters.
  -/
  has_univ : Set.univ ∈ seed.sets

class Filter.Proper (F : FilterSeed α): Prop where
  no_empty_set : ∅ ∉ F.sets

def FilterSeed.grow (S : FilterSeed α) : Filter α :=
  let sets := {x : Set α | ∃ y ∈ S.sets, y ⊆ x}
  have larger : S.sets ⊆ sets := by
    apply Set.subset_setOf.mpr
    intro x _
    exists x
  have nonempty : sets.Nonempty := Set.Nonempty.mono larger S.nonempty
  have isotone : {x y : Set α} → x ∈ sets → x ⊆ y → y ∈ sets := by
    intro x y h_x x_sub_y
    apply Set.mem_setOf.mpr
    suffices ∃ a ∈ S.sets, a ⊆ x by
      let ⟨a, a_in_S, a_sub_x⟩ := this
      exists a
      apply And.intro a_in_S
      exact Set.Subset.trans a_sub_x x_sub_y
    assumption
  have has_univ : Set.univ ∈ sets := by
    apply Set.mem_setOf.mpr
    suffices ∃ y, y ∈ sets by
      let ⟨y, y_in_sets⟩ := this
      let ⟨a, ⟨a_in_S_sets, a_sub_y⟩⟩ := y_in_sets.out
      exists a
      apply And.intro a_in_S_sets
      simp only [Set.subset_univ]
    exact nonempty
  have meet : {x y : Set α } → (x ∈ sets) → (y ∈ sets) → x ∩ y ∈ sets := by
    intro x y x_in_sets y_in_sets
    show ∃ c ∈ S.sets, c ⊆ x ∩ y
    let ⟨a, ⟨a_in_S_sets, a_sub_x⟩⟩ := x_in_sets.out
    let ⟨b, ⟨b_in_S_sets, b_sub_y⟩⟩ := y_in_sets.out
    have _ : a ∩ b ⊆ x ∩ y := Set.inter_subset_inter a_sub_x b_sub_y
    have _ : a ∩ b ∈ S.sets := S.meet a_in_S_sets b_in_S_sets
    exists a ∩ b
  {
    seed := { sets, meet, nonempty }
    isotone,
    has_univ
  }
